/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.metaTemplating.Comment;
import org.xtext.example.mydsl.metaTemplating.Escaped;
import org.xtext.example.mydsl.metaTemplating.EscapedString;
import org.xtext.example.mydsl.metaTemplating.Header;
import org.xtext.example.mydsl.metaTemplating.Import;
import org.xtext.example.mydsl.metaTemplating.Instructions;
import org.xtext.example.mydsl.metaTemplating.Iterator;
import org.xtext.example.mydsl.metaTemplating.Libraries;
import org.xtext.example.mydsl.metaTemplating.MetaPh;
import org.xtext.example.mydsl.metaTemplating.MetaProperty;
import org.xtext.example.mydsl.metaTemplating.MetaTemplatingPackage;
import org.xtext.example.mydsl.metaTemplating.Model;
import org.xtext.example.mydsl.metaTemplating.Ph;
import org.xtext.example.mydsl.metaTemplating.Property;
import org.xtext.example.mydsl.metaTemplating.Query;
import org.xtext.example.mydsl.metaTemplating.Rule;
import org.xtext.example.mydsl.metaTemplating.Statement;
import org.xtext.example.mydsl.metaTemplating.SubProperty;
import org.xtext.example.mydsl.metaTemplating.SubQuery;
import org.xtext.example.mydsl.services.MetaTemplatingGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractMetaTemplatingSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MetaTemplatingGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MetaTemplatingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetaTemplatingPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case MetaTemplatingPackage.ESCAPED:
				sequence_Escaped(context, (Escaped) semanticObject); 
				return; 
			case MetaTemplatingPackage.ESCAPED_STRING:
				sequence_EscapedString(context, (EscapedString) semanticObject); 
				return; 
			case MetaTemplatingPackage.HEADER:
				sequence_Header(context, (Header) semanticObject); 
				return; 
			case MetaTemplatingPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MetaTemplatingPackage.INSTRUCTIONS:
				sequence_Instructions(context, (Instructions) semanticObject); 
				return; 
			case MetaTemplatingPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case MetaTemplatingPackage.LIBRARIES:
				sequence_Libraries(context, (Libraries) semanticObject); 
				return; 
			case MetaTemplatingPackage.META_PH:
				sequence_MetaPh(context, (MetaPh) semanticObject); 
				return; 
			case MetaTemplatingPackage.META_PROPERTY:
				sequence_MetaProperty(context, (MetaProperty) semanticObject); 
				return; 
			case MetaTemplatingPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MetaTemplatingPackage.PH:
				sequence_Ph(context, (Ph) semanticObject); 
				return; 
			case MetaTemplatingPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MetaTemplatingPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case MetaTemplatingPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MetaTemplatingPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case MetaTemplatingPackage.SUB_PROPERTY:
				sequence_SubProperty(context, (SubProperty) semanticObject); 
				return; 
			case MetaTemplatingPackage.SUB_QUERY:
				sequence_SubQuery(context, (SubQuery) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     (word+=ID | word+=ID)
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EscapedString returns EscapedString
	 *
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_EscapedString(ISerializationContext context, EscapedString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.ESCAPED_STRING__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.ESCAPED_STRING__STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEscapedStringAccess().getStrSTRINGTerminalRuleCall_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Escaped returns Escaped
	 *
	 * Constraint:
	 *     (
	 *         char='#' | 
	 *         char='{' | 
	 *         char='}' | 
	 *         char='[' | 
	 *         char=']' | 
	 *         char=',' | 
	 *         char=';' | 
	 *         char='(' | 
	 *         char=')' | 
	 *         char=':' | 
	 *         char='<' | 
	 *         char='>' | 
	 *         char='''
	 *     )
	 */
	protected void sequence_Escaped(ISerializationContext context, Escaped semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Header
	 *
	 * Constraint:
	 *     (libs+=Libraries* imports+=Import*)
	 */
	protected void sequence_Header(ISerializationContext context, Header semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.IMPORT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.IMPORT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instructions returns Instructions
	 *
	 * Constraint:
	 *     (statement=Statement | iterator=Iterator | rule=Rule | comment=Comment)
	 */
	protected void sequence_Instructions(ISerializationContext context, Instructions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (element=ID query=Query body+=Instructions*)
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Libraries returns Libraries
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Libraries(ISerializationContext context, Libraries semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.LIBRARIES__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.LIBRARIES__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLibrariesAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaPh returns MetaPh
	 *
	 * Constraint:
	 *     (property=Property tag=STRING?)
	 */
	protected void sequence_MetaPh(ISerializationContext context, MetaPh semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaProperty returns MetaProperty
	 *
	 * Constraint:
	 *     property=Property
	 */
	protected void sequence_MetaProperty(ISerializationContext context, MetaProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.META_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.META_PROPERTY__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaPropertyAccess().getPropertyPropertyParserRuleCall_1_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (header=Header content+=Instructions*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ph returns Ph
	 *
	 * Constraint:
	 *     (property=Property metaProperty=MetaProperty?)
	 */
	protected void sequence_Ph(ISerializationContext context, Ph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (property=ID subProperties+=SubProperty*)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     ((item=ID | ref=MetaPh) subQuery+=SubQuery*)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (element=ID property=Property tag=ID body+=Instructions*)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (text=ID | char=Escaped | string=EscapedString | placeholder=Ph | metaPlaceholder=MetaPh)
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubProperty returns SubProperty
	 *
	 * Constraint:
	 *     property=ID
	 */
	protected void sequence_SubProperty(ISerializationContext context, SubProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.SUB_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.SUB_PROPERTY__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubPropertyAccess().getPropertyIDTerminalRuleCall_1_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubQuery returns SubQuery
	 *
	 * Constraint:
	 *     (item=ID | ref=MetaPh)
	 */
	protected void sequence_SubQuery(ISerializationContext context, SubQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
