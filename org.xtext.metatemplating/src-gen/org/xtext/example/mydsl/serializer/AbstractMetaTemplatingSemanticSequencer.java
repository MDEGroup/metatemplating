/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.metaTemplating.Escaped;
import org.xtext.example.mydsl.metaTemplating.EscapedString;
import org.xtext.example.mydsl.metaTemplating.Filter;
import org.xtext.example.mydsl.metaTemplating.Header;
import org.xtext.example.mydsl.metaTemplating.Import;
import org.xtext.example.mydsl.metaTemplating.Instructions;
import org.xtext.example.mydsl.metaTemplating.Iterator;
import org.xtext.example.mydsl.metaTemplating.Libraries;
import org.xtext.example.mydsl.metaTemplating.MetaFilter;
import org.xtext.example.mydsl.metaTemplating.MetaInject;
import org.xtext.example.mydsl.metaTemplating.MetaPh;
import org.xtext.example.mydsl.metaTemplating.MetaTemplatingPackage;
import org.xtext.example.mydsl.metaTemplating.Model;
import org.xtext.example.mydsl.metaTemplating.Note;
import org.xtext.example.mydsl.metaTemplating.Ph;
import org.xtext.example.mydsl.metaTemplating.PhProperty;
import org.xtext.example.mydsl.metaTemplating.PhSubProperty;
import org.xtext.example.mydsl.metaTemplating.Property;
import org.xtext.example.mydsl.metaTemplating.Query;
import org.xtext.example.mydsl.metaTemplating.Rule;
import org.xtext.example.mydsl.metaTemplating.Statement;
import org.xtext.example.mydsl.metaTemplating.SubParameter;
import org.xtext.example.mydsl.metaTemplating.SubProperty;
import org.xtext.example.mydsl.metaTemplating.SubQuery;
import org.xtext.example.mydsl.services.MetaTemplatingGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractMetaTemplatingSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MetaTemplatingGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MetaTemplatingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetaTemplatingPackage.ESCAPED:
				sequence_Escaped(context, (Escaped) semanticObject); 
				return; 
			case MetaTemplatingPackage.ESCAPED_STRING:
				sequence_EscapedString(context, (EscapedString) semanticObject); 
				return; 
			case MetaTemplatingPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case MetaTemplatingPackage.HEADER:
				sequence_Header(context, (Header) semanticObject); 
				return; 
			case MetaTemplatingPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MetaTemplatingPackage.INJECT:
				sequence_Inject(context, (org.xtext.example.mydsl.metaTemplating.Inject) semanticObject); 
				return; 
			case MetaTemplatingPackage.INSTRUCTIONS:
				sequence_Instructions(context, (Instructions) semanticObject); 
				return; 
			case MetaTemplatingPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case MetaTemplatingPackage.LIBRARIES:
				sequence_Libraries(context, (Libraries) semanticObject); 
				return; 
			case MetaTemplatingPackage.META_FILTER:
				sequence_MetaFilter(context, (MetaFilter) semanticObject); 
				return; 
			case MetaTemplatingPackage.META_INJECT:
				sequence_MetaInject(context, (MetaInject) semanticObject); 
				return; 
			case MetaTemplatingPackage.META_PH:
				sequence_MetaPh(context, (MetaPh) semanticObject); 
				return; 
			case MetaTemplatingPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MetaTemplatingPackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case MetaTemplatingPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.example.mydsl.metaTemplating.Parameter) semanticObject); 
				return; 
			case MetaTemplatingPackage.PH:
				sequence_Ph(context, (Ph) semanticObject); 
				return; 
			case MetaTemplatingPackage.PH_PROPERTY:
				sequence_PhProperty(context, (PhProperty) semanticObject); 
				return; 
			case MetaTemplatingPackage.PH_SUB_PROPERTY:
				sequence_PhSubProperty(context, (PhSubProperty) semanticObject); 
				return; 
			case MetaTemplatingPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MetaTemplatingPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case MetaTemplatingPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MetaTemplatingPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case MetaTemplatingPackage.SUB_PARAMETER:
				sequence_SubParameter(context, (SubParameter) semanticObject); 
				return; 
			case MetaTemplatingPackage.SUB_PROPERTY:
				sequence_SubProperty(context, (SubProperty) semanticObject); 
				return; 
			case MetaTemplatingPackage.SUB_QUERY:
				sequence_SubQuery(context, (SubQuery) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EscapedString returns EscapedString
	 *
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_EscapedString(ISerializationContext context, EscapedString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.ESCAPED_STRING__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.ESCAPED_STRING__STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEscapedStringAccess().getStrSTRINGTerminalRuleCall_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Escaped returns Escaped
	 *
	 * Constraint:
	 *     (
	 *         char='n' | 
	 *         char='s' | 
	 *         char='t' | 
	 *         char='#' | 
	 *         char='{' | 
	 *         char='}' | 
	 *         char='[' | 
	 *         char=']' | 
	 *         char=',' | 
	 *         char='.' | 
	 *         char=';' | 
	 *         char='(' | 
	 *         char=')' | 
	 *         char=':' | 
	 *         char='<' | 
	 *         char='>' | 
	 *         char='''
	 *     )
	 */
	protected void sequence_Escaped(ISerializationContext context, Escaped semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     (condition=Query truebody+=Instructions* falsebody+=Instructions*)
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Header
	 *
	 * Constraint:
	 *     (libs+=Libraries* imports+=Import*)
	 */
	protected void sequence_Header(ISerializationContext context, Header semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.IMPORT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.IMPORT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Inject returns Inject
	 *
	 * Constraint:
	 *     code=STRING
	 */
	protected void sequence_Inject(ISerializationContext context, org.xtext.example.mydsl.metaTemplating.Inject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.INJECT__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.INJECT__CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInjectAccess().getCodeSTRINGTerminalRuleCall_1_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instructions returns Instructions
	 *
	 * Constraint:
	 *     (
	 *         note=Note | 
	 *         statement=Statement | 
	 *         filter=Filter | 
	 *         metaFilter=MetaFilter | 
	 *         iterator=Iterator | 
	 *         rule=Rule
	 *     )
	 */
	protected void sequence_Instructions(ISerializationContext context, Instructions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (element=ID query=Query body+=Instructions*)
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Libraries returns Libraries
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Libraries(ISerializationContext context, Libraries semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.LIBRARIES__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.LIBRARIES__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLibrariesAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaFilter returns MetaFilter
	 *
	 * Constraint:
	 *     (condition=Property truebody+=Instructions* falsebody+=Instructions*)
	 */
	protected void sequence_MetaFilter(ISerializationContext context, MetaFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaInject returns MetaInject
	 *
	 * Constraint:
	 *     code=STRING
	 */
	protected void sequence_MetaInject(ISerializationContext context, MetaInject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.META_INJECT__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.META_INJECT__CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaInjectAccess().getCodeSTRINGTerminalRuleCall_1_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaPh returns MetaPh
	 *
	 * Constraint:
	 *     (property=Property tag=ID?)
	 */
	protected void sequence_MetaPh(ISerializationContext context, MetaPh semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (header=Header content+=Instructions*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Note returns Note
	 *
	 * Constraint:
	 *     word+=ID+
	 */
	protected void sequence_Note(ISerializationContext context, Note semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (par=ID params+=SubParameter*)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.example.mydsl.metaTemplating.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhProperty returns PhProperty
	 *
	 * Constraint:
	 *     (property=ID subProperties+=PhSubProperty*)
	 */
	protected void sequence_PhProperty(ISerializationContext context, PhProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhSubProperty returns PhSubProperty
	 *
	 * Constraint:
	 *     ((method=ID params=Parameter?) | property=ID | metaProperty=Property)
	 */
	protected void sequence_PhSubProperty(ISerializationContext context, PhSubProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ph returns Ph
	 *
	 * Constraint:
	 *     property=PhProperty
	 */
	protected void sequence_Ph(ISerializationContext context, Ph semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.PH__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.PH__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhAccess().getPropertyPhPropertyParserRuleCall_1_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (property=ID subProperties+=SubProperty*)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     ((item=ID | ref=MetaPh) subQuery+=SubQuery*)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (element=ID property=Property tag=ID body+=Instructions*)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         text=ID | 
	 *         char=Escaped | 
	 *         string=EscapedString | 
	 *         inject=Inject | 
	 *         metaInject=MetaInject | 
	 *         placeholder=Ph | 
	 *         metaPlaceholder=MetaPh
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubParameter returns SubParameter
	 *
	 * Constraint:
	 *     par=ID
	 */
	protected void sequence_SubParameter(ISerializationContext context, SubParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaTemplatingPackage.Literals.SUB_PARAMETER__PAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaTemplatingPackage.Literals.SUB_PARAMETER__PAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubParameterAccess().getParIDTerminalRuleCall_1_0(), semanticObject.getPar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubProperty returns SubProperty
	 *
	 * Constraint:
	 *     ((method=ID params=Parameter?) | property=ID)
	 */
	protected void sequence_SubProperty(ISerializationContext context, SubProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubQuery returns SubQuery
	 *
	 * Constraint:
	 *     (((methItem=ID | methRef=MetaPh) params=Parameter?) | item=ID | ref=MetaPh)
	 */
	protected void sequence_SubQuery(ISerializationContext context, SubQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
